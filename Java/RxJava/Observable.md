## 事件类型

1. Observatble声明的类型为T的值
2. 完成事件
3. 错误事件

## 操作符

- cache
> 当第一个订阅者出现的时候cache将订阅的委托发布给底层的Observable，同时会保存一个副本，供后续的订阅者使用

注：
1.切记不要和无穷流进行组合 

- serialize
> 可以确保事件是序列化和有序的，可以确保完成和错误后，不会再有事件发出

- fromCallable
> 简化的对try-catch的回调定义

- timer
> 延迟发布事件


- interval
>  固定的事件间隔发布事件

注：
1. 可以用以定期轮询数据、刷新用户界面或者建模时间的推移



## 说明
1. 工厂方法默认是在客户端线程中执行
2. subscribe实际上会`阻塞`客户端线程
3. 尽可能频繁地检查isUnsubscrived标记，避免将事件发送给不想再接收新事件地订阅者
4. 建议避免自己生成线程，而是采用声明式并发和自定义调度器
5. 合理地使用subscriber.add注册回调，可以很好地节约资源（对于稳定、频繁的流，可能不需要这种模式）
6. 错误的传递建议再回调定义种中用`try-catch`
7. 在使用的时候需要注意，Observable的数据是Hot类型的还是Cold类型的
	1. 对于Cold类型的数据，
		1. 需要注意其副作用，比如查询数据库或打开连接
		2. 可以获得完整且一致的事件集
		3. 对时间没有依赖性，可能会生成多次
	2. 对于Hot类型的数据的订阅，
		1. 类似于电话监听，完全是解耦和独立的
		2. 适用于无法控制事件源的场景下
		3. 无法确保获取到所有的事件
		4. 对时间有依赖，并且非常重要，一般能够将事件限定到一个时间范围
