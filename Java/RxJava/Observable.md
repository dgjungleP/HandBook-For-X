## 事件类型

1. Observatble声明的类型为T的值
2. 完成事件
3. 错误事件

## 操作符
> 操作符的组合才是Rx真正强大的地方，一般就是链接多个操作符，将流分成多个子流，然后再将他们联合起来


- cache
> 当第一个订阅者出现的时候cache将订阅的委托发布给底层的Observable，同时会保存一个副本，供后续的订阅者使用

注：
1.切记不要和无穷流进行组合 

- serialize
> 可以确保事件是序列化和有序的，可以确保完成和错误后，不会再有事件发出

- fromCallable
> 简化的对try-catch的回调定义

- timer
> 延迟发布事件


- interval
>  固定的事件间隔发布事件

注：
1. 可以用以定期轮询数据、刷新用户界面或者建模时间的推移

- doOnNext
> 可以对流中的数据进行查看，必须保证不去对事件进行修改，类似于侦听模式

- concatMap
> 相对于flatMap，它能保证上游数据的顺序，避免重叠

- merge/mergeWith
> 捕获所有的事件，聚合到一个流中，它不能保证数据的顺序

注：
1. 适用于将多个数据源视为统一来源的情况

- zip/zipWith
> 事件以成对的方式进行组合，将多个事件限速到同一个频率

- combineLatest
> 任意一个上游的流产生事件的时候，就会使用另一个流的最新已知值，作用是对称的

- withLatestFrom
> 任意一个上游的流产生事件的时候，就会使用另一个流的最新已知值，作用是单向的

- startWith
> 向事件流的头部添加一个事件

- amb/ambWith
> 会订阅上游操控的所有的Obervable，并且等待第一个事件发布，捕捉到第一个事件后，其他的Overable直接被抛弃掉，作用是对称的

- collect
> 将有限事件流，转化成另一个流

- distinct/distinctUntilChanged
> 去重，只获得唯一的事件


- compose
> 将已有的操作组合在一起


- lift
> 可以实现任意的操作符，利用`Subscriber` 


## 使用方式

1. 将普通的集合转换到Observable
2. 在组合阻塞代码和非阻塞代码的时候，使用BlockingQbservable
3. 使用defer拥抱`延迟执行`
4. 更好的语义化异常
5. 合理的转化和快速的使用转化为并发模式
6. 定期轮询轮询以获取变更
7. 使用调度器来实现并发，于subscribeOn和observeOn结合使用

## 说明
1. 工厂方法默认是在客户端线程中执行
2. subscribe实际上会`阻塞`客户端线程
3. 尽可能频繁地检查isUnsubscrived标记，避免将事件发送给不想再接收新事件地订阅者
4. 建议避免自己生成线程，而是采用声明式并发和自定义调度器
5. 合理地使用subscriber.add注册回调，可以很好地节约资源（对于稳定、频繁的流，可能不需要这种模式）
6. 错误的传递建议再回调定义种中用`try-catch`
7. 在使用的时候需要注意，Observable的数据是Hot类型的还是Cold类型的
	1. 对于Cold类型的数据，
		1. 需要注意其副作用，比如查询数据库或打开连接
		2. 可以获得完整且一致的事件集
		3. 对时间没有依赖性，可能会生成多次
	2. 对于Hot类型的数据的订阅，
		1. 类似于电话监听，完全是解耦和独立的
		2. 适用于无法控制事件源的场景下
		3. 无法确保获取到所有的事件
		4. 对时间有依赖，并且非常重要，一般能够将事件限定到一个时间范围


## 案例

### 重构回调API
> 可以进行线程控制、生命周期管理和清理

