## 操作系统工具

### 工具包
#### Unix
- sar
- vmstat
- iostat
- prstat
- netstat
- nicstat
#### Windows
- 图形化资源监视器
- typeperf

### 监控信息
- CPU使用率（让CPU的使用率尽可能的高）
	- `用户态`时间
	- `系统态`时间，任何使用底层系统资源的操作，都会占用`系统态`时间
> 注意：
> -  `CUP队列`的情况，一般试图运行的线程数超过了可用的CPU,性能就会下降
> -  检查应用性能时，首先应该审查CPU时间
> -  优化代码的目的是提升而不是降低CPU的使用率
> -  在试图深入优化应用前，应该先弄清楚为何CPU使用率低
> -  程序无法获得CPU周期的原因
> 	- 锁
> 	- 外部资源的瓶颈
> CPU空闲的可能的原因：
> - 应用程序阻塞在同步原语上，知道锁释放后才能继续执行
> - 应用程序在等待某些东西，如数据库调用返回的响应
> - 应用程序没事可做
> - CPU在有工作可做时也可能空闲
- 内存使用率
- 磁盘使用率
	- 与应用相关，如果应用正在做大量的`磁盘I/O`操作,那么I/O容易成为瓶颈
	- 没有有效的缓冲，磁盘I/O会`非常低`
	- 超过了磁盘的承载，磁盘I/O会`非常高`
	- 有助于监控系统是否在进行`内存交换`（即从主内存移动数据到磁盘或者反过来）
		- 进行`内存交换`的系统，一般来说性能比较差
>  - 即使不直接写磁盘的应用，系统交换任然会影响他们的性能
>  - 写入磁盘应用的瓶颈，要么是因为写入的效率太低（吞吐量太低），要么是因为写入太多的数据（吞吐量太高）
- 网络使用率
	- 没有充分利用网络，所以`带宽`很低
	- 过度使用，写入网络接口的总数据量超过了它所处理的量，`带宽不足`
>  - 对于本地的以太网来说，使用率超过40%就意味着饱和
>  - 对基于网络的应用，务必要监控网络是不是它的瓶颈
>  - 网络的瓶颈，可能是写数据效率太低（吞吐量太低），或者写入太多的数据（吞吐量太高）


## Java监控工具
- jcmd，打印Java进程所涉及的`基本类、线程和VM信息`，可用于`脚本`
- jconsole，提供JVM活动的图形化试图，包括`线程的使用、类的使用、GC活动`
- jhat，读取`内存堆转储`，用于`事后分析`
- jmap，提供`堆转储和其他JVM使用信息`，可用于`脚本`,`堆转储`必须在`事后分析工具`中使用
- jinfo，查看`JVM系统属性`，可以`动态设置`一些系统属性，可用于`脚本`
> 只能修改标记为manageable的标志
- jstack，转储Java进程的`栈信息`，可用于`脚本`
- jvisualvm，监视JVM的`GUI工具`，可用来`剖析运行的应用`，`分析JVM堆转储`

### 可观测的领域
- 基本的VM信息
	- 运行时间
	- 系统属性
	- JVM版本
	- JVM命令行
	- JVM调优标志
		> 值`:=`表示没有使用默认值，值`=`表示使用的默认值
		> 导致标志不使用默认值的情况：
		> - 标志值直接在命令行指定
		> - 其他标志简介改变了该标志
		> - JVM自动优化计算出来的默认值
- 线程信息
- 类信息
- 实时GC分析
- 堆转储的事后处理
- JVM的性能分析

## 性能分析工具
> 几乎所有的Java性能分析工具都是用Java写的，并以`关联`应用的方式进行性能分析
> - 性能分析器开启与分析应用之间的socket(JVMTI,jvm工具接口)（或者其他通信通道）
> 两种模式
> - 采样模式
> - 探查模式

### 采样分析器
> - 采样分析器是最常用的分析器
> - 采样分析器的采样频率相对较低，所以引入的测量失真也较小
> - 不同的采样分析器，针对不同的应用各有所长
> - 采样分析器只能在线程位于`安全点`时采集线程样本---基本上只有在JVM分配内存的时候
> 	- get方法永远都不会进入`安全点`，所以永远都不会被采样

##### 安全点偏差
- 什么情况下会自动进入安全点
	- 在同步锁上阻塞
	- 等待I/O时阻塞
	- 等待管程时阻塞
	- 线程挂起
	- 正在执行Java本地接口（JNI）代码（执行GC锁定函数除外）
	- JVM设置标记

##### 获取栈轨迹方式
- 线程进入安全点
- 在程序层面，通过`AsyncGetCallTrace`接口实现（异步分析器）

##### 查看采样信息的方式
> - Oracle Developer Studio分析器
> - Async-profiler 生成`火焰图`
> - 调用树


### 探查分析器
> - 探查分析器可以获取更过的应用信息，但是对应用的侵入性更强
> - 探查分析器应该仅在小代码区域、一些类和包中设置，以限制对应用性能的影响
> - 最好用于二级分析

### 本地分析器
- Oracle Solaris Studio
> - 本地新能分析器可以提供JVM和应用代码内部的信息
> - 如果本地性能分析器显示GC占用了主要的CPU时间，优化垃圾收集器就是正确的做法

### 原生分析器
> 分析原生代码
> - 提供JVM代码和应用程序代码的内部运行信息
> - 包括原生库中和原生内存分配中的操作
> - 快速反馈代码在GC中花费的时间

### 注意
#### 阻塞方法和线程时间线
> - 阻塞方法是不会消耗CPU时间的
> - 审视线程的`执行模式`而不是分析器给阻塞方法所标记的时间，更有价值
> - 线程被阻塞可能是性能问题，也可能不是，需要明确他们为什么被阻塞
> - 通过整被阻塞的方法调用，分析线程的时间线，可以辨认出被阻塞的线程


### Java任务控制(JMC)
> 可以向任何被监控的应用`MBean`发起JMX`调用`
### Java飞行记录器(JFR)

> - 是JVM的`历史事件`，可以用来诊断JVM的历史性能和操作
##### 有价值的信息
- 在记录期间所有的垃圾收集，包括持续事件和收集类型
- 有多少应用对象和多长时间被清理
- 并发收集过程中是否有对象提升或疏散失败
- GC算法的配置参数
- 已分配的特ing种类对象的信息


## [Next JIT编译器](./JIT.md)
