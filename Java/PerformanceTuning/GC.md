> 很多时候，我们没有机会重写代码，又面临需要提高Java应用的性能压力，这种情况下对垃圾收集器的调优就变得至关重要

## 概述
### 垃圾收集的步骤
1. 查找不再使用的对象
2. 释放对这些对象所管理的内存
3. 对堆的内存布局进行压缩整理
> - 简单的清理不足以合理的时候内存，有时候我们还需要进行内存整理，防止内存碎片
> - `STW`对性能的影响最大，尽量减少这种停顿是最关键的考虑因素

### 类型
- Serial收集器（单CPU环境）
- Throughout（Parallel）收集器
- Concurrent收集器（CMS）
- G1收集器

## 指令
- -XX:+PrintGCDetails 打印GC日志

## 垃圾收集器
> - 所有的垃圾收集器都遵循同一个方式，划分`老年代`、`新生代`,`新生代`划分为`Eden`和`Survivor`
> - 所有的垃圾收集算法，在对`新生代`进行垃圾回收时都存在`STW`的现象
> - 各种收集器，使用各种不同的方法对`老年代`进行收集和压缩

### 分代垃圾收集器
> 初衷：
> - 处理大量的临时对象 
#### 特性
- 垃圾收集器会在执行回收的时候，暂停所有的应用线程（`STW`）
- 能带来更短的`STW`时间
- 发生的频率更高
- 垃圾收集的时候自动进行了一次压缩整理

### 考虑的因素
> 对单个请求的响应事件有要求

- 单个请求会受停顿的事件影响--对受`Full GC`长时间的停顿影响更大，想尽可能地缩短响应事件，那么选择使用`Concurrent收集器`
- 如果平均响应事件比最大响应事件(百分位)更重要，采用`Throughput收集器`
- 使用`Concurrent收集器`避免长时间的停顿，会额外消耗`CPU`

> 为批量请求的应用选择的原则

- 如果CPU足够强，使用`Concurrent收集器`可以避免发生`Full GC`，可以让任务更快
- 如果CPU有限，使用`Concurrent收集器`额外的CPU消耗会让批量任务消耗更多的时间