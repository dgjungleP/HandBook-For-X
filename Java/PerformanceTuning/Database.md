### JDBC
#### 评估JDBC驱动的时候需要考虑的问题
- 工作在哪里执行
	- 服务器做更多工作的`瘦驱动`
	- 程序做更多工作的`胖驱动`
- JDBC类型
	- 1型驱动ODBC
		- 性能一般很差，只有当必须通过ODBC协议进行通信时选择
	- 2型驱动原生代码
		- 性能非常好，但是部署起来很麻烦，直接调用供应商提供的C库，使用起来也比较麻烦
	- 3型驱动纯Java代码
		- 为特定的架构设计，通常有个中间件
	- 4型驱动纯Java代码
		- 容易部署，性能也较好，通过实现数据库供应商的线路协议进行沟通

#### JDBC连接池
- 注意`预处理语句缓存`
- 尽量让程序中的任何线程都不必等待可用的数据库连接，并且保持数据库有足够的资源来处理负载
- 如果数据库已经过载，限制连接池的工作量，可能会更有好处


### 预处理语句和语句池
功效
- 提高性能，可以`重用`正在执行的SQL信息
- 安全性更高
- 可编程性更好

> 如果只使用一次的话，可以避免使用预处理语句

池化时需要考虑的因素
- JDBC连接池
- JDBC驱动配置

#### 语句池
- 建立语句池
	- 每个连接都会建立自己的语句池实例
	- 语句池缓存的预处理语句会占用堆空间，注意对`GC`的影响
- 管理语句池
	- 没有标准
	- 要么通过配置JDBC驱动来创建和管理，要么在程序代码中自己创建和管理（使用框架时，一般都是框架在管理）
	- 由于没有准，请确保JDBC驱动和数据层框架只有一个地方在管理语句池

### 事务
> 不能让对性能的渴望超过了程序的正确性

性能损失的原因
- 数据库事务的创建
- 数据库事务的提交

问题
- 如何对事务进行编程，以让事务本身变得高效
- 如何在事务中持有数据库锁，使得应用程序在整体上进行扩展


#### JDBC事务控制
- 事务的提交成本很高，尽量在一个事务中执行尽可能多的工作
- 由于事务可能持有锁，尽量让事务执行的事件更短
- 合理使用`批处理`

#### 事务隔离和锁
隔离级别
- 串行读
- 可重复读
- 读提交
- 不可重复读
- 无事务
锁
- 悲观锁
	- FOR UPDATE
- 乐观锁
	- 通过定义版本
	- 在数据访问不存在竞争的情况下，有助于改善锁性能

### 结果集处理
> 使用预处理语句对象的`setFetchSize()`，避免一次性加载所有的数据，导致数据量过大对性能影响


### JPA
> JPA很多的性能提升是通过改变实体类的字节码来实现的
> 优化一般都是在`persistence.xml`中配置一些特殊的属性

实现
- EclipseLink

#### 写优化
- 写入更少的字段

#### 读优化
- 读取更少的数据
	- 延时加载
- 一次读取更多的数据
	- 在查询中使用JOIN
	- 批处理和查询

#### 缓存
- 二级缓存，全局缓存
- 一级缓存，实体管理器的本地缓存

#### 扩展
- `提取组`
- `立即提取`
- `连续提取`
- `命名查询`



### 总结
- 尽量能通过适当的配置JDBC和JPA来进行批量读写
- 优化应用程序的SQL语句，对于JDBC来说，就是基本的`标准SQL命令`问题，对于JPA程序来说，要考虑`L2缓存`
- 经历减少锁的使用
- 确保使用预处理语句池
- 确保使用适当大小的连接池
- 设置合理的事务范围


## [Next API技巧](./API.md)