## 基本目标的冲突
- 谨慎的创建对象并尽快的丢弃他们
- 尽量重用创建的对象

## 术语
- 浅大小
	- 对象本身的大小，如果时引用，则只是引用大小
- 深大小
	- 对象的本身加上引用的对象的大小
- 保留大小
	- 和深大小一致，区别仅在于引用的对象是否是共享的
- 支配者
	- 保留大量堆空间的对象
## 分析
> 借助我们之前提到的JVM工具查看
> - 在了解代码中哪些对象应该优化之前，先了解哪些对象在消耗内存

### 堆直方图
> 获取时，往往会触发Full GC,所以不要在性能测试稳定的时候获取
> 命令行
> - jcmd pid GC.class_histogram
> - jmap -histo pid

### 堆转储
> 堆的更详细信息
> 命令行
> - jcmd pid GC.heap_dump file
> - jmap -dump:live,file=file pid
> 可视化工具
> - jvisualvm
> - Eclipse Memory Analyzer Tool (mat)

### 内存溢出错误
#### 产生的原因
##### JVM没有可用的原生内存
>- 产生原生内存溢出，对堆进行调优也不能解决问题
>- 要解决错误中提到的问题
##### 元空间不足
> 产生的原因
> 	- 分配的元空间已经放不下应用程序使用的类
> 	- 类加载器的内存泄露（常见于动态加载类的服务器）
##### Java堆本身内存不足
> 产生的原因
> 	- 缺乏内存空间
> 	- 应用程序发生了`内存泄漏`
> 		- 集合是发生`内存泄漏`的常见原因
> 帮助指令
> - -XX:+HeapDumpOnOutOfMemoryError
> - -XX:HeapDumpPath=\<path\>
> - -XX:+HeapDumpAfterFullGC
> - -XX:+HeapDumpBeforeFullGC
> - -XX:+ExitOnOutOfMemoryError
##### JVM花费了太多的时间GC
> 触发条件（同时满足）
> - Full GC花费的时间超过了设定值（-XX:GCTimeLImit=N）
> - 一次Full GC回收的内存小于设定值（-XX:GCHeapFreeLimit=N）
> - 以上条件在`5次`连续的Full GC周期中都成立
> - -XX:UseGCOverheadLimit这是为true

## 高效使用内存的方法

#### 减少内存使用

##### 减小对象大小
> - 这里`大小`取决于我们想要的是浅大小、深大小还是保留大小，并且包括一些隐藏的`对象头字段`
> - 不能忽略`对象对齐`对对象大小的影响
> - 即使实例变量为`null`，也是堆消耗对象内的空间的
> OpenJDK中计算对象大小的工具
> - jol


##### 使用对象的`延迟初始化`
> - 在相关操作不频繁的时候使用
> - 注意线程安全的要求
> - 记得及早清理 ，注意过时引用问题

##### 使用`标准化对象`
> - 不可变对象的单一表示被成为对象的`标准版本`
> - 通过标准化`消除不可变对象的副本`，可以极大地减少应用程序地堆使用量\

## 对象地生命周期管理
> 找到`什么时候`以及`如何改变`对象的正常的生命周期

#### 对象重用
> 常常使用的方式
> - 对象池
> 	- 线程池
> 	- 软引用
> - 线程局部变量
> 当初始化对象需要很长时间的时候，注意去谈对象池或线程局部变量

##### JDK和Java程序经常复用的对象
- 线程池
- 软引用
- JDBC连接池
- 大数组
- 原生NIO缓冲区
- 与安全相关的类
- 字符串编码器和解码器对象
- StringBuilder帮助类
- 随机数生成器
- 从DNS查询中获取名字
- ZIP编码器和解码器

##### 对象池的性能影响
- GC影响
- 同步
- 限流

##### 线程局部变量的性能影响
- 生命周期管理
- 基数性
- 同步


#### 软应用、弱应用和其他引用
##### 术语说明
- 引用
	- 指向任意类型的`指针`
- 不确定引用
	- 表示任意特殊类型的引用，实际上是一个`对象实例`
- 所引对象
	- 被`不确定引用`封装的对象


> 对垃圾回收期的影响
> - 它会使用更多的内存
> - 不确定引用被垃圾回收器回收至少需要`两个GC`周期
> 指令， -XX:+PrintReferenceGC

##### 软引用
>对象在未来有很`大概率`被重用，但是想让垃圾回收期`回收最近没有用到`的对象
>- 指令，-XX:SoftRefLRUPolicyMSPerMB=N
>	-  当满足以下条件是，可以考虑提升
>		- 堆中有大量的空闲空间可用
>		- 软引用的访问频率不高
>- 在创建的实例不多的情况下，使用才有效果

- 什么时候软引用会被清理
	-所有对象必须没有被其他的强引用所引用
	- 内存完全耗尽或`抖动`过于严重

##### 弱引用
> 相关的引用对象被`几个线程同时使用`的时候使用
> 	- 垃圾回收期在每个GC周期都会回收只有弱引用的对象

##### 终结器和最终引用
> 命令行
> - jcmd pid GC.run_finalization
> - jmap -finalizerinfo pid
> 不推荐使用`finalizer()`，改用`Cleaner类`

##### 清理器对象

#### 压缩的普通对象指针
> 指令，-XX:+UseCompressedOops


## [Next 原生内存最佳实践](./NatureMemory.md)
