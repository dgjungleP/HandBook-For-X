## 基本目标的冲突
- 谨慎的创建对象并尽快的丢弃他们
- 尽量重用创建的对象

## 术语
- 浅大小
	- 对象本身的大小，如果时引用，则只是引用大小
- 深大小
	- 对象的本身加上引用的对象的大小
- 保留大小
	- 和深大小一致，区别仅在于引用的对象是否是共享的
- 支配者
	- 保留大量堆空间的对象
## 分析
> 借助我们之前提到的JVM工具查看
> - 在了解代码中哪些对象应该优化之前，先了解哪些对象在消耗内存

### 堆直方图
> 获取时，往往会触发Full GC,所以不要在性能测试稳定的时候获取
> 命令行
> - jcmd pid GC.class_histogram
> - jmap -histo pid

### 堆转储
> 堆的更详细信息
> 命令行
> - jcmd pid GC.heap_dump file
> - jmap -dump:live,file=file pid
> 可视化工具
> - jvisualvm
> - Eclipse Memory Analyzer Tool (mat)

### 内存溢出错误
#### 产生的原因
##### JVM没有可用的原生内存
>- 产生原生内存溢出，对堆进行调优也不能解决问题
>- 要解决错误中提到的问题
##### 元空间不足
> 产生的原因
> 	- 分配的元空间已经放不下应用程序使用的类
> 	- 类加载器的内存泄露（常见于动态加载类的服务器）
##### Java堆本身内存不足
> 产生的原因
> 	- 缺乏内存空间
> 	- 应用程序发生了`内存泄漏`
> 		- 集合是发生`内存泄漏`的常见原因
> 帮助指令
> - -XX:+HeapDumpOnOutOfMemoryError
> - -XX:HeapDumpPath=\<path\>
> - -XX:+HeapDumpAfterFullGC
> - -XX:+HeapDumpBeforeFullGC
> - -XX:+ExitOnOutOfMemoryError
##### JVM花费了太多的时间GC
> 触发条件（同时满足）
> - Full GC花费的时间超过了设定值（-XX:GCTimeLImit=N）
> - 一次Full GC回收的内存小于设定值（-XX:GCHeapFreeLimit=N）
> - 以上条件在`5次`连续的Full GC周期中都成立
> - -XX:UseGCOverheadLimit这是为true

## 高效使用内存的方法

#### 减少内存使用

##### 减小对象大小
> - 这里`大小`取决于我们想要的是浅大小、深大小还是保留大小，并且包括一些隐藏的`对象头字段`
> - 不能忽略`对象对齐`对对象大小的影响
> - 即使实例变量为`null`，也是堆消耗对象内的空间的
> OpenJDK中计算对象大小的工具
> - jol


##### 使用对象的`延迟初始化`
> - 在相关操作不频繁的时候使用
> - 注意线程安全的要求
> - 记得及早清理 ，注意过时引用问题

##### 使用`标准化对象`
> - 不可变对象的单一表示被成为对象的`标准版本`
> - 通过标准化`消除不可变对象的副本`，可以极大地减少应用程序地堆使用量