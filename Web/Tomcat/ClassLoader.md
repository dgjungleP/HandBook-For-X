## JAVA中的类加载器

### 启动类加载器-Bootstrap
> - 加载Java核心类到JVM中，目录来自于`%JAVA_HOME%/jre/lib`
> - 使用原生代码实现不继承ClassLoader 
> - 是所有其他加载器的最终父类
> - 无法被Java程序使用

### 扩展类加载器-Extension
> - 加载Java的扩展对象，目录来自于`%JAVA_HOME%/jre/lib/ext`
> - 由启动类加载器加载
> - 父类是启动类加载器

### 应用程序类加载器-Application/System
> - 加载用户类路径，目录为`%CLASSPATH%`
> - 由启动类加载器加载
> - 父类是扩展类加载器
> - 通过`ClassLoader.getSystemClassLoader()`获取

### 自定义类加载器
> - 用户自定义的类加载器
> - 都是由应用程序类加载器加载


#### 加载原则
- 越重要的越优先加载
- 从安全性考虑，先加载的类加载器会充当下一个类加载器的父加载器
- 全盘负责机制，如果加载一个类，那么这个类的所有依赖和引用都由这个加载器加载，除非显示地指定另一个加载器加载
- 隔离性，在JVM中，两个类相等那么必须是类加载器一致以及完全匹配类名一致


## 双亲委派模型
> 会在加载器加载类时首先委托给父类加载器加载，除非父类加载器并不能加载，自己才加载

### 打破双亲委派模式
- 集成ClassLoader
- 重写`loadClass`和`findClass`方法

## Tomcat中的类加载器
### 目的
- 同一个Web服务器中，各个项目各自使用的Java类库要互相隔离
- 同一个Web服务器中，各个Web项目之间可以提供共享的Java类库
- 服务器的类库与应用程序的类库互相独立
- 对支持JSP的Web服务器，应该支持热插拔功能


## Next [Tomcat 中的 JNDI](./JNDI.md)